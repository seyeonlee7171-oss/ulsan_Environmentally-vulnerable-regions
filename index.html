<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì§€ì—­ë³„ í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ì‹œê°í™” ë§µ</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    /* ===== Base Reset ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 18px;
      color: #111827;
    }

    /* ===== Layout Card ===== */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,0.28);
      min-height: calc(100vh - 36px);
      display: flex;
      flex-direction: column;
    }

    /* ===== Header ===== */
    .header {
      padding: 26px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
    }
    .header-inner{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }
    .header-text{
      min-width:0;
    }
    .header h1 {
      font-size: 22px;
      letter-spacing: -0.2px;
      margin-bottom: 6px;
    }
    .header p {
      opacity: 0.92;
      font-size: 14px;
      line-height: 1.4;
    }

    /* ===== Header Logo ===== */
    .header-logo{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      text-decoration:none;
      transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
      flex-shrink: 0;
    }
    .header-logo:hover{
      background: rgba(255,255,255,0.22);
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(0,0,0,0.18);
    }
    .header-logo img{
      height: 34px;
      width: auto;
      display:block;
    }

    /* ===== Main grid ===== */
    .content {
      flex: 1;
      display: grid;
      grid-template-columns: 340px 1fr;
      min-height: 0;
    }

    /* ===== Panel ===== */
    .panel {
      padding: 18px 18px;
      background: #f8f9fa;
      border-right: 1px solid #e9ecef;
      min-height: 0;
      overflow-y: auto;
    }
    .panel-card {
      background: #fff;
      border: 1px solid #e9ecef;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      margin-bottom: 14px;
    }
    .label {
      display: block;
      font-weight: 700;
      font-size: 13px;
      color: #374151;
      margin: 10px 0 8px;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    select, button {
      height: 42px;
      border-radius: 10px;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 0 12px;
      border: 2px solid #667eea;
      background: #fff;
      color: #111827;
      outline: none;
      transition: all .22s ease;
      cursor: pointer;
    }
    select:hover {
      border-color: #764ba2;
      box-shadow: 0 2px 10px rgba(102, 126, 234, 0.25);
    }
    select:focus {
      border-color: #764ba2;
      box-shadow: 0 0 0 4px rgba(118, 75, 162, 0.15);
    }

    .btn {
      width: 100%;
      border: none;
      cursor: pointer;
      font-weight: 800;
      color: #fff;
      background: #667eea;
      transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
    }
    .btn:hover {
      background: #764ba2;
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(102,126,234,0.28);
    }
    .btn:active {
      transform: translateY(0px);
      box-shadow: none;
    }
    #exportBtn {
      background: #10b981;
    }
    #exportBtn:hover {
      background: #059669;
      box-shadow: 0 10px 18px rgba(16,185,129,0.28);
    }
    #vulnerabilityBtn {
      background: #ef4444;
    }
    #vulnerabilityBtn:hover {
      background: #dc2626;
      box-shadow: 0 10px 18px rgba(239,68,68,0.28);
    }

    /* ===== Toggle Button ===== */
    .toggle-container {
      margin-top: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .toggle-label {
      font-weight: 700;
      font-size: 13px;
      color: #374151;
    }
    .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
      background: #e5e7eb;
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .toggle-switch.active {
      background: #667eea;
    }
    .toggle-knob {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .toggle-switch.active .toggle-knob {
      transform: translateX(24px);
    }
    .toggle-status {
      font-size: 12px;
      color: #6b7280;
      font-weight: 600;
    }

    .hint {
      margin-top: 12px;
      font-size: 12.5px;
      color: #6b7280;
      line-height: 1.45;
    }
    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(102, 126, 234, 0.12);
      color: #4f46e5;
      font-weight: 700;
      font-size: 12px;
      margin-right: 6px;
    }

    /* ===== Map area ===== */
    .map-wrap {
      padding: 16px;
      background: #fff;
      min-height: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      min-height: 520px;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.10);
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.06);
    }

    /* ===== Footer ===== */
    .footer {
      padding: 14px 18px;
      text-align: center;
      color: #6b7280;
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
      font-size: 12.5px;
    }

    /* ===== Leaflet legend style ===== */
    .legend {
      background: rgba(255,255,255,0.96);
      padding: 10px 12px;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.12);
      backdrop-filter: blur(6px);
    }
    .legend .title {
      font-weight: 800;
      margin-bottom: 8px;
      color: #111827;
      font-size: 13px;
    }
    .legend .item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 6px 0;
      font-size: 12.5px;
      color: #374151;
    }
    .legend .swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.22);
    }
    .legend .meta {
      margin-top: 8px;
      font-size: 11.5px;
      color: #6b7280;
    }

    /* ===== Responsive ===== */
    @media (max-width: 980px) {
      body { padding: 10px; }
      .content { grid-template-columns: 1fr; }
      .panel { border-right: none; border-bottom: 1px solid #e9ecef; }
      #map { min-height: 520px; }

      .header-inner{ align-items:flex-start; }
      .header-logo img{ height: 28px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-inner">
        <div class="header-text">
          <h1>ì§€ì—­ë³„ í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ì‹œê°í™” ë§µ</h1>
          <p>í–‰ì •ë™ë³„ ì§€í‘œë¥¼ ì„ íƒí•´ ë‹¨ê³„í˜• ìƒ‰ìƒ ì§€ë„ë¡œ í™•ì¸í•©ë‹ˆë‹¤.</p>
        </div>

        <!-- ìš¸ì‚°ì—°êµ¬ì› ë¡œê³  - í´ë¦­ ì‹œ ì‚¬ì´íŠ¸ë¡œ ì´ë™ -->
        <a class="header-logo" href="https://www.uri.re.kr/" target="_blank" rel="noopener">
          <img src="./assets/logo.png" alt="ìš¸ì‚°ì—°êµ¬ì› ë¡œê³ " />
        </a>
      </div>
    </div>

    <div class="content">
      <aside class="panel">
        <!-- ê°œë³„ ë³€ìˆ˜ ì„ íƒ ì¹´ë“œ -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">ë³€ìˆ˜</span>
          </div>

          <label class="label" for="varSelect">ê°œë³„ ë³€ìˆ˜ ì„ íƒ</label>
          <select id="varSelect"></select>

          <!-- ì •ê·œí™” ON/OFF í† ê¸€ -->
          <div class="toggle-container">
            <span class="toggle-label">ì •ê·œí™”</span>
            <div class="toggle-switch" id="normalizeToggle">
              <div class="toggle-knob"></div>
            </div>
            <span class="toggle-status" id="normalizeStatus">OFF</span>
          </div>

          <div class="hint" style="margin-top: 12px;">
            <div>â€» ì •ê·œí™” ON: 0~10 ì ìˆ˜ë¥¼ 1~10 levelë¡œ í‘œì‹œ</div>
            <div style="margin-top:6px;">â€» ì •ê·œí™” OFF: ì›ë³¸ ë°ì´í„° ê°’ ê·¸ëŒ€ë¡œ í‘œì‹œ</div>
          </div>
        </div>

        <!-- ë„ë©”ì¸ ì„ íƒ ì¹´ë“œ -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">ë„ë©”ì¸</span>
          </div>

          <label class="label" for="domainSelect">ë„ë©”ì¸ë³„ ì ìˆ˜</label>
          <select id="domainSelect">
            <option value="">-- ë„ë©”ì¸ ì„ íƒ --</option>
            <option value="í™˜ê²½ì••ë ¥">í™˜ê²½ì••ë ¥ (0~5ì )</option>
            <option value="í™˜ê²½ìˆ˜ì¤€">í™˜ê²½ìˆ˜ì¤€ (0~10ì )</option>
            <option value="í™˜ê²½ë³´ê±´ìˆ˜ì¤€">í™˜ê²½ë³´ê±´ìˆ˜ì¤€ (0~5ì )</option>
            <option value="ë¯¼ê°ì¸êµ¬">ë¯¼ê°ì¸êµ¬ (0~3ì )</option>
            <option value="ì‚¬íšŒê²½ì œì ìˆ˜ì¤€">ì‚¬íšŒê²½ì œì  ìˆ˜ì¤€ (0~3ì )</option>
          </select>

          <div class="hint" style="margin-top: 12px;">
            <div>â€» ê° ë„ë©”ì¸ë³„ ë³€ìˆ˜ë“¤ì˜ í‰ê·  ì ìˆ˜</div>
            <div style="margin-top:6px;">â€» ì†Œìˆ˜ì  í•œìë¦¬ë¡œ í‘œì‹œ</div>
          </div>
        </div>

        <!-- í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ì¹´ë“œ -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">ì¢…í•©</span>
          </div>

          <button class="btn" id="vulnerabilityBtn" type="button">
            ğŸ¯ í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ë³´ê¸°
          </button>

          <div class="hint" style="margin-top: 12px;">
            <div>â€» í™˜ê²½ì••ë ¥ Ã— (í™˜ê²½ìˆ˜ì¤€+í™˜ê²½ë³´ê±´ìˆ˜ì¤€) Ã— (ë¯¼ê°ì¸êµ¬+ì‚¬íšŒê²½ì œìˆ˜ì¤€)</div>
            <div style="margin-top:6px;">â€» ë…¹ìƒ‰(ë‚®ìŒ) â†’ í™©ìƒ‰(ì¤‘ê°„) â†’ ì ìƒ‰(ë†’ìŒ)</div>
          </div>
        </div>

        <!-- ê¸°íƒ€ ê¸°ëŠ¥ ì¹´ë“œ -->
        <div class="panel-card">
          <div style="margin-top: 0px;">
            <button class="btn" id="resetBtn" type="button">ì§€ë„ ì´ˆê¸°í™”(ì „ì²´ë³´ê¸°)</button>
          </div>

          <div style="margin-top: 10px;">
            <button class="btn" id="exportBtn" type="button">ğŸ“¸ ì´ë¯¸ì§€ë¡œ ì €ì¥</button>
          </div>

          <div class="hint" style="margin-top: 12px;">
            <div>ë°ì´í„° íŒŒì¼: <code>ulsan_dong_indicators.geojson</code></div>
          </div>
        </div>
      </aside>

      <main class="map-wrap">
        <div id="map"></div>
      </main>
    </div>

    <div class="footer">
      ì§€ì—­ë³„ í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ì‹œê°í™” ë§µ Â· ì •ì  ì›¹(HTML/JS) Â· Leaflet ê¸°ë°˜
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <script>
    // ====== ë„ë©”ì¸ë³„ ë³€ìˆ˜ ë§¤í•‘ (í•„ìš”ì‹œ ìˆ˜ì •) ======
    const DOMAIN_MAPPING = {
      "í™˜ê²½ì••ë ¥": [
        "ì¸êµ¬ë°€ë„(ëª…/kã¡)",
        "ìœ ë™ì¸êµ¬(ëª…)",
        "í–‰ì •êµ¬ì—­ ë‚´ ì‚°ë‹¨ ë©´ì ",
        "í™˜ê²½ì˜¤ì—¼ë¬¼ì§ˆë°°ì¶œ ì‚¬ì—…ì¥ ìˆ˜(ê°œ)",
        "ì œì¡°ì—… ì¢…ì‚¬ì ìˆ˜(ëª…)",
        "ì¶”ì •êµí†µëŸ‰(ëŒ€/ì¼)",
        "ì°¨ëŸ‰ì£¼í–‰ê±°ë¦¬(km)",
        "ë„ë¡œê¸¸ì´(km)",
        "ìœ í•´ë¬¼ì§ˆ ë°°ì¶œ(CAPSS)"
      ],
      "í™˜ê²½ìˆ˜ì¤€": [
        "PM 2.5 ë†ë„",
        "NO2 ë†ë„",
        "O3 ë†ë„",
        "í™˜ê²½ ì†ŒìŒ"
      ],
      "í™˜ê²½ë³´ê±´ìˆ˜ì¤€": [
        "ì²œì‹ ìœ ë³‘ë¥ ",
        "ë¹„ì—¼ ìœ ë³‘ë¥ ",
        "COPD ìœ ë³‘ë¥ ",
        "ì•„í† í”¼í”¼ë¶€ì—¼ìœ ë³‘ë¥ ",
        "ê²°ë§‰ì—¼ ìœ ë³‘ë¥ "
      ],
      "ë¯¼ê°ì¸êµ¬": [
        "65ì„¸ ì´ìƒ ë…¸ë ¹ì¸êµ¬ ë¹„ìœ¨",
        "5ì„¸ ë¯¸ë§Œ ì–´ë¦°ì´ ë¹„ìœ¨"
      ],
      "ì‚¬íšŒê²½ì œì ìˆ˜ì¤€": [
        "ë…¸í›„ê±´ì¶•ë¬¼ í˜„í™©",
        "ê³µì›ì ‘ê·¼ì„±",
        "ë³‘ì›ìˆ˜",
        "ê¸°ì´ˆìƒí™œìˆ˜ê¸‰ì ë¹„ìœ¨",
        "ì´ˆì¤‘ê³  í•™êµ ìˆ˜",
        "í•™ì›, êµìŠµì†Œ ìˆ˜",
        "ì†Œë“ì •ë„"
      ]
    };

    // ë„ë©”ì¸ë³„ ì ìˆ˜ ë²”ìœ„
    const DOMAIN_SCORES = {
      "í™˜ê²½ì••ë ¥": { min: 0, max: 5 },
      "í™˜ê²½ìˆ˜ì¤€": { min: 0, max: 10 },
      "í™˜ê²½ë³´ê±´ìˆ˜ì¤€": { min: 0, max: 5 },
      "ë¯¼ê°ì¸êµ¬": { min: 0, max: 3 },
      "ì‚¬íšŒê²½ì œì ìˆ˜ì¤€": { min: 0, max: 3 }
    };

    // ====== ì„¤ì • ======
    const GEOJSON_URL = "./ulsan_dong_indicators.geojson";
    const NAME_FIELD = "ADM_NM";
    const K_VALUE = 10; // ê³ ì •ê°’

    let map = L.map("map").setView([35.55, 129.30], 11);
    const base = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(map);

    let geoLayer = null;
    let legendControl = null;
    let geoData = null;
    let isNormalized = false; // ì •ê·œí™” ìƒíƒœ
    let currentMode = 'variable'; // 'variable', 'domain', 'vulnerability'

    function getColor(idx, k) {
      const ramps = {
        5:  ["#ffffcc","#fed976","#feb24c","#fd8d3c","#e31a1c"],
        7:  ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#f03b20","#bd0026"],
        10: ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#bd0026","#800026","#4d0018"]
      };
      const pal = ramps[k] || ramps[10];
      return pal[Math.min(idx, pal.length - 1)];
    }

    // ì·¨ì•½ì§€ìˆ˜ìš© ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ë…¹ìƒ‰ -> í™©ìƒ‰ -> ì ìƒ‰)
    function getVulnerabilityColor(idx, k) {
      const ramps = {
        5:  ["#22c55e","#84cc16","#eab308","#f97316","#ef4444"],
        7:  ["#22c55e","#65a30d","#84cc16","#eab308","#f97316","#f87171","#ef4444"],
        10: ["#22c55e","#4ade80","#84cc16","#a3e635","#eab308","#fbbf24","#f97316","#fb923c","#ef4444","#dc2626"]
      };
      const pal = ramps[k] || ramps[10];
      return pal[Math.min(idx, pal.length - 1)];
    }

    function fmt(v, isDomain = false) {
      if (v === null || v === undefined || Number.isNaN(v)) return "NA";
      const n = parseFloat(v);
      
      if (isDomain) {
        return n.toFixed(1); // ë„ë©”ì¸ ì ìˆ˜ëŠ” ì†Œìˆ˜ì  1ìë¦¬
      }
      
      if (isNormalized) {
        return Math.round(n).toString(); // ì •ê·œí™”ëœ ê°’ì€ ì •ìˆ˜ë¡œ í‘œì‹œ
      }
      return Math.round(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function computeNaturalBreaks(values, k) {
      return ss.jenks(values, k); // ê¸¸ì´ k+1 ê²½ê³„
    }

    // Min-Max ì •ê·œí™” í•¨ìˆ˜ (0~10 ë²”ìœ„)
    function normalizeToRange(values, minRange = 0, maxRange = 10) {
      const validVals = values.filter(v => v !== null && v !== undefined && !Number.isNaN(v));
      if (validVals.length === 0) return values;
      
      const minVal = Math.min(...validVals);
      const maxVal = Math.max(...validVals);
      
      if (minVal === maxVal) {
        // ëª¨ë“  ê°’ì´ ê°™ìœ¼ë©´ ì¤‘ê°„ê°’ ë°˜í™˜
        const midVal = (minRange + maxRange) / 2;
        return values.map(v => (v !== null && v !== undefined && !Number.isNaN(v)) ? midVal : v);
      }
      
      return values.map(v => {
        if (v === null || v === undefined || Number.isNaN(v)) return v;
        return minRange + ((v - minVal) / (maxVal - minVal)) * (maxRange - minRange);
      });
    }

    // ë„ë©”ì¸ ì ìˆ˜ ê³„ì‚°
    function calculateDomainScores() {
      if (!geoData) return;

      geoData.features.forEach(feature => {
        // ê° ë³€ìˆ˜ë¥¼ 0~10ìœ¼ë¡œ ì •ê·œí™”
        Object.keys(DOMAIN_MAPPING).forEach(domain => {
          const vars = DOMAIN_MAPPING[domain];
          const values = [];
          
          vars.forEach(varName => {
            if (feature.properties[varName + '_normalized_0_10'] !== undefined) {
              const val = feature.properties[varName + '_normalized_0_10'];
              if (val !== null && val !== undefined && !Number.isNaN(val)) {
                values.push(val);
              }
            }
          });
          
          if (values.length > 0) {
            // í‰ê·  ê³„ì‚°
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            
            // ë„ë©”ì¸ë³„ ì ìˆ˜ ë²”ìœ„ë¡œ ì¬ì •ê·œí™”
            const scoreRange = DOMAIN_SCORES[domain];
            const domainScore = (avg / 10) * (scoreRange.max - scoreRange.min) + scoreRange.min;
            
            feature.properties['domain_' + domain] = domainScore;
          } else {
            feature.properties['domain_' + domain] = null;
          }
        });

        // í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ê³„ì‚°
        const envPressure = feature.properties['domain_í™˜ê²½ì••ë ¥'] || 0;
        const envQuality = feature.properties['domain_í™˜ê²½ìˆ˜ì¤€'] || 0;
        const envHealth = feature.properties['domain_í™˜ê²½ë³´ê±´ìˆ˜ì¤€'] || 0;
        const sensitive = feature.properties['domain_ë¯¼ê°ì¸êµ¬'] || 0;
        const socioEcon = feature.properties['domain_ì‚¬íšŒê²½ì œì ìˆ˜ì¤€'] || 0;
        
        const vulnerability = envPressure * (envQuality + envHealth) * (sensitive + socioEcon);
        feature.properties['vulnerability_index'] = vulnerability;
      });
    }

    // ëª¨ë“  ë³€ìˆ˜ë¥¼ 0~10ìœ¼ë¡œ ì •ê·œí™”
    function normalizeAllVariables() {
      if (!geoData) return;

      const allVars = populateVarsFromGeoJSON(geoData);
      
      allVars.forEach(varName => {
        const allVals = geoData.features.map(f => f.properties[varName]);
        const normalized = normalizeToRange(allVals, 0, 10);
        
        geoData.features.forEach((f, idx) => {
          f.properties[varName + '_normalized_0_10'] = normalized[idx];
        });
      });
    }

    function buildLegend(breaks, k, displayName, mode = 'variable') {
      if (legendControl) legendControl.remove();

      legendControl = L.control({ position: "bottomright" });
      legendControl.onAdd = function () {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `<div class="title">${displayName}</div>`;
        
        if (mode === 'variable' && isNormalized) {
          // ë³€ìˆ˜ì˜ ì •ê·œí™”ëœ ê²½ìš° level í‘œê¸°
          for (let i = 0; i < k; i++) {
            const color = getColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${i + 1} level</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">Level 1 (ë‚®ìŒ) ~ Level ${k} (ë†’ìŒ)</div>`;
        } else if (mode === 'vulnerability') {
          // ì·¨ì•½ì§€ìˆ˜ëŠ” ë…¹í™©ì  ìƒ‰ìƒ
          for (let i = 0; i < k; i++) {
            const from = breaks[i];
            const to = breaks[i + 1];
            const color = getVulnerabilityColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${fmt(from, true)} â€“ ${fmt(to, true)}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">ë…¹ìƒ‰(ì•ˆì „) â†’ í™©ìƒ‰(ë³´í†µ) â†’ ì ìƒ‰(ì·¨ì•½)</div>`;
        } else {
          // ì›ë³¸ ê°’ ë˜ëŠ” ë„ë©”ì¸ ì ìˆ˜
          for (let i = 0; i < k; i++) {
            const from = breaks[i];
            const to = breaks[i + 1];
            const color = getColor(i, k);
            const isDomain = mode === 'domain';
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${fmt(from, isDomain)} â€“ ${fmt(to, isDomain)}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">Natural Breaks, k=${k}</div>`;
        }
        return div;
      };
      legendControl.addTo(map);
    }

    function styleFeature(feature, dataKey, breaks, k, mode = 'variable') {
      let v = feature.properties[dataKey];
      
      if (v === null || v === undefined || Number.isNaN(v)) {
        return { color: "#9ca3af", weight: 1, fillOpacity: 0.25, fillColor: "#e5e7eb" };
      }
      
      let idx = k - 1;
      for (let i = 0; i < k; i++) {
        if (v <= breaks[i + 1]) { idx = i; break; }
      }
      
      const colorFunc = mode === 'vulnerability' ? getVulnerabilityColor : getColor;
      return { color: "#6b7280", weight: 1, fillOpacity: 0.78, fillColor: colorFunc(idx, k) };
    }

    function renderVariable(varName) {
      if (!geoData) return;
      currentMode = 'variable';

      const rawVals = geoData.features
        .map(f => f.properties[varName])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (rawVals.length === 0) {
        alert(`'${varName}' ë³€ìˆ˜ì— ìœ íš¨í•œ ìˆ«ìê°’ì´ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }

      let vals = rawVals;
      let dataKey = varName;
      
      if (isNormalized) {
        // 0~10 ì •ê·œí™”ëœ ê°’ ì‚¬ìš©
        vals = geoData.features
          .map(f => f.properties[varName + '_normalized_0_10'])
          .filter(v => typeof v === "number" && !Number.isNaN(v));
        dataKey = varName + '_normalized_0_10';
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'variable'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          let displayValue = feature.properties[varName];
          
          if (isNormalized) {
            const normVal = feature.properties[varName + '_normalized_0_10'];
            const level = Math.round(normVal);
            layer.bindTooltip(`<b>${nm}</b><br/>${varName}: ${level} level`, { sticky: true });
          } else {
            layer.bindTooltip(`<b>${nm}</b><br/>${varName}: ${fmt(displayValue)}`, { sticky: true });
          }
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      buildLegend(breaks, kEff, varName, 'variable');
    }

    function renderDomain(domainName) {
      if (!geoData) return;
      currentMode = 'domain';

      const dataKey = 'domain_' + domainName;
      const vals = geoData.features
        .map(f => f.properties[dataKey])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (vals.length === 0) {
        alert(`'${domainName}' ë„ë©”ì¸ ì ìˆ˜ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'domain'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          const score = feature.properties[dataKey];
          layer.bindTooltip(`<b>${nm}</b><br/>${domainName}: ${fmt(score, true)}ì `, { sticky: true });
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      const scoreRange = DOMAIN_SCORES[domainName];
      const displayName = `${domainName} (${scoreRange.min}~${scoreRange.max}ì )`;
      buildLegend(breaks, kEff, displayName, 'domain');
    }

    function renderVulnerability() {
      if (!geoData) return;
      currentMode = 'vulnerability';

      const dataKey = 'vulnerability_index';
      const vals = geoData.features
        .map(f => f.properties[dataKey])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (vals.length === 0) {
        alert('í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'vulnerability'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          const score = feature.properties[dataKey];
          layer.bindTooltip(`<b>${nm}</b><br/>í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜: ${fmt(score, true)}`, { sticky: true });
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      buildLegend(breaks, kEff, 'í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜', 'vulnerability');
    }

    // ì´ë¯¸ì§€ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜
    function exportMapAsImage() {
      const mapElement = document.getElementById('map');
      let fileName = 'ìš¸ì‚°_í™˜ê²½ë³´ê±´ì·¨ì•½ì§€ìˆ˜';
      
      if (currentMode === 'variable') {
        const varSelect = document.getElementById('varSelect');
        const varName = varSelect.value;
        const normalizeText = isNormalized ? '_ì •ê·œí™”' : '';
        fileName += `_${varName}${normalizeText}`;
      } else if (currentMode === 'domain') {
        const domainSelect = document.getElementById('domainSelect');
        const domainName = domainSelect.value;
        fileName += `_${domainName}`;
      } else if (currentMode === 'vulnerability') {
        fileName += '_ì¢…í•©ì·¨ì•½ì§€ìˆ˜';
      }
      
      const timestamp = new Date().toISOString().slice(0, 10);
      
      html2canvas(mapElement, {
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        scale: 2
      }).then(canvas => {
        const link = document.createElement('a');
        link.download = `${fileName}_${timestamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      }).catch(err => {
        console.error('ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', err);
        alert('ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
      });
    }

    function populateVarsFromGeoJSON(geojson) {
      const props = geojson.features?.[0]?.properties || {};
      const candidates = Object.keys(props).filter(k => 
        k !== NAME_FIELD && 
        k !== "join_key" && 
        !k.endsWith("_normalized_0_10") &&
        !k.startsWith("domain_") &&
        k !== "vulnerability_index"
      );
      const vars = candidates.filter(vn =>
        geojson.features.some(f => typeof f.properties[vn] === "number" && !Number.isNaN(f.properties[vn]))
      );
      return vars;
    }

    async function init() {
      const res = await fetch(GEOJSON_URL);
      geoData = await res.json();

      // ëª¨ë“  ë³€ìˆ˜ë¥¼ 0~10ìœ¼ë¡œ ì •ê·œí™”
      normalizeAllVariables();
      
      // ë„ë©”ì¸ ì ìˆ˜ ê³„ì‚°
      calculateDomainScores();

      const varSelect = document.getElementById("varSelect");
      const domainSelect = document.getElementById("domainSelect");
      const resetBtn = document.getElementById("resetBtn");
      const exportBtn = document.getElementById("exportBtn");
      const vulnerabilityBtn = document.getElementById("vulnerabilityBtn");
      const normalizeToggle = document.getElementById("normalizeToggle");
      const normalizeStatus = document.getElementById("normalizeStatus");

      const vars = populateVarsFromGeoJSON(geoData);
      if (vars.length === 0) {
        varSelect.innerHTML = `<option value="">(í‘œì‹œí•  ë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤)</option>`;
        return;
      }

      varSelect.innerHTML = vars.map(v => `<option value="${v}">${v}</option>`).join("");

      const defaultVar = vars.includes("ì¸êµ¬ë°€ë„(ëª…/kã¡)") ? "ì¸êµ¬ë°€ë„(ëª…/kã¡)" : vars[0];
      varSelect.value = defaultVar;

      renderVariable(defaultVar);

      // ë³€ìˆ˜ ì„ íƒ ë³€ê²½ ì‹œ
      varSelect.addEventListener("change", () => {
        domainSelect.value = "";
        renderVariable(varSelect.value);
      });

      // ë„ë©”ì¸ ì„ íƒ ë³€ê²½ ì‹œ
      domainSelect.addEventListener("change", () => {
        if (domainSelect.value) {
          renderDomain(domainSelect.value);
        }
      });

      // í™˜ê²½ë³´ê±´ ì·¨ì•½ì§€ìˆ˜ ë²„íŠ¼
      vulnerabilityBtn.addEventListener("click", () => {
        domainSelect.value = "";
        renderVulnerability();
      });

      // ì§€ë„ ì´ˆê¸°í™” ë²„íŠ¼
      resetBtn.addEventListener("click", () => {
        if (geoLayer) map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      });

      // ì´ë¯¸ì§€ ë‚´ë³´ë‚´ê¸° ë²„íŠ¼
      exportBtn.addEventListener("click", () => {
        exportMapAsImage();
      });

      // ì •ê·œí™” í† ê¸€
      normalizeToggle.addEventListener("click", () => {
        if (currentMode === 'variable') {
          isNormalized = !isNormalized;
          normalizeToggle.classList.toggle("active");
          normalizeStatus.textContent = isNormalized ? "ON" : "OFF";
          renderVariable(varSelect.value);
        }
      });
    }

    init();
  </script>
</body>
</html>
