<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>지역별 환경보건 취약지수 시각화 맵</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-easyprint@2.1.9/dist/bundle.css"
  />

  <style>
    /* ===== Base Reset ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, "Malgun Gothic", "맑은 고딕", sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 18px;
      color: #111827;
    }

    /* ===== Layout Card ===== */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,0.28);
      min-height: calc(100vh - 36px);
      display: flex;
      flex-direction: column;
    }

    /* ===== Header ===== */
    .header {
      padding: 26px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
    }
    .header-inner{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }
    .header-text{
      min-width:0;
    }
    .header h1 {
      font-size: 22px;
      letter-spacing: -0.2px;
      margin-bottom: 6px;
    }
    .header p {
      opacity: 0.92;
      font-size: 14px;
      line-height: 1.4;
    }

    /* ===== Header Logo ===== */
    .header-logo{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      text-decoration:none;
      transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
      flex-shrink: 0;
    }
    .header-logo:hover{
      background: rgba(255,255,255,0.22);
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(0,0,0,0.18);
    }
    .header-logo img{
      height: 34px;
      width: auto;
      display:block;
    }

    /* ===== Main grid ===== */
    .content {
      flex: 1;
      display: grid;
      grid-template-columns: 340px 1fr;
      min-height: 0;
    }

    /* ===== Panel ===== */
    .panel {
      padding: 18px 18px;
      background: #f8f9fa;
      border-right: 1px solid #e9ecef;
      min-height: 0;
      overflow-y: auto;
    }
    .panel-card {
      background: #fff;
      border: 1px solid #e9ecef;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      margin-bottom: 14px;
    }
    .label {
      display: block;
      font-weight: 700;
      font-size: 13px;
      color: #374151;
      margin: 10px 0 8px;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    select, button {
      height: 42px;
      border-radius: 10px;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 0 12px;
      border: 2px solid #667eea;
      background: #fff;
      color: #111827;
      outline: none;
      transition: all .22s ease;
      cursor: pointer;
    }
    select:hover {
      border-color: #764ba2;
      box-shadow: 0 2px 10px rgba(102, 126, 234, 0.25);
    }
    select:focus {
      border-color: #764ba2;
      box-shadow: 0 0 0 4px rgba(118, 75, 162, 0.15);
    }

    .btn {
      width: 100%;
      border: none;
      cursor: pointer;
      font-weight: 800;
      color: #fff;
      background: #667eea;
      transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
    }
    .btn:hover {
      background: #764ba2;
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(102,126,234,0.28);
    }
    .btn:active {
      transform: translateY(0px);
      box-shadow: none;
    }
    #exportBtn {
      background: #10b981;
    }
    #exportBtn:hover {
      background: #059669;
      box-shadow: 0 10px 18px rgba(16,185,129,0.28);
    }
    #vulnerabilityBtn {
      background: #ef4444;
    }
    #vulnerabilityBtn:hover {
      background: #dc2626;
      box-shadow: 0 10px 18px rgba(239,68,68,0.28);
    }

    /* ===== Toggle Button ===== */
    .toggle-container {
      margin-top: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .toggle-label {
      font-weight: 700;
      font-size: 13px;
      color: #374151;
    }
    .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
      background: #e5e7eb;
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .toggle-switch.active {
      background: #667eea;
    }
    .toggle-knob {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .toggle-switch.active .toggle-knob {
      transform: translateX(24px);
    }
    .toggle-status {
      font-size: 12px;
      color: #6b7280;
      font-weight: 600;
    }

    .hint {
      margin-top: 12px;
      font-size: 12.5px;
      color: #6b7280;
      line-height: 1.45;
    }
    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(102, 126, 234, 0.12);
      color: #4f46e5;
      font-weight: 700;
      font-size: 12px;
      margin-right: 6px;
    }

    /* ===== Map area ===== */
    .map-wrap {
      padding: 16px;
      background: #fff;
      min-height: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      min-height: 520px;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.10);
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.06);
    }

    /* ===== Footer ===== */
    .footer {
      padding: 14px 18px;
      text-align: center;
      color: #6b7280;
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
      font-size: 12.5px;
    }

    /* ===== Leaflet legend style ===== */
    .legend {
      background: rgba(255,255,255,0.96);
      padding: 10px 12px;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.12);
      backdrop-filter: blur(6px);
    }
    .legend .title {
      font-weight: 800;
      margin-bottom: 8px;
      color: #111827;
      font-size: 13px;
    }
    .legend .item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 6px 0;
      font-size: 12.5px;
      color: #374151;
    }
    .legend .swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.22);
    }
    .legend .meta {
      margin-top: 8px;
      font-size: 11.5px;
      color: #6b7280;
    }

    /* ===== Leaflet Tooltip z-index ===== */
    .leaflet-tooltip {
      z-index: 99999 !important;
      position: relative !important;
    }
    .leaflet-tooltip-pane {
      z-index: 99999 !important;
    }
    .leaflet-pane {
      z-index: auto !important;
    }
    .leaflet-overlay-pane {
      z-index: 400 !important;
    }
    .leaflet-tooltip-pane {
      z-index: 99999 !important;
      pointer-events: none !important;
    }

    /* ===== Export Mode (이미지 저장 시에만 적용) ===== */
    .exporting .leaflet-container {
      background: #ffffff !important;
    }
    .exporting .legend {
      backdrop-filter: none !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
    }

    /* ===== Responsive ===== */
    @media (max-width: 980px) {
      body { padding: 10px; }
      .content { grid-template-columns: 1fr; }
      .panel { border-right: none; border-bottom: 1px solid #e9ecef; }
      #map { min-height: 520px; }

      .header-inner{ align-items:flex-start; }
      .header-logo img{ height: 28px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-inner">
        <div class="header-text">
          <h1>지역별 환경보건 취약지수 시각화 맵</h1>
          <p>행정동별 지표를 선택해 단계형 색상 지도로 확인합니다.</p>
        </div>

        <!-- 울산연구원 로고 - 클릭 시 사이트로 이동 -->
        <a class="header-logo" href="https://www.uri.re.kr/" target="_blank" rel="noopener">
          <img src="./assets/logo.png" alt="울산연구원 로고" />
        </a>
      </div>
    </div>

    <div class="content">
      <aside class="panel">
        <!-- 개별 변수 선택 카드 -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">변수</span>
          </div>

          <label class="label" for="varSelect">개별 변수 선택</label>
          <select id="varSelect"></select>

          <!-- 정규화 ON/OFF 토글 -->
          <div class="toggle-container">
            <span class="toggle-label">정규화</span>
            <div class="toggle-switch" id="normalizeToggle">
              <div class="toggle-knob"></div>
            </div>
            <span class="toggle-status" id="normalizeStatus">OFF</span>
          </div>

          <div class="hint" style="margin-top: 12px;">
            <div>※ 정규화 ON: 0~10 점수를 1~10 level로 표시</div>
            <div style="margin-top:6px;">※ 정규화 OFF: 원본 데이터 값 그대로 표시</div>
          </div>
        </div>

        <!-- 도메인 선택 카드 -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">도메인</span>
          </div>

          <label class="label" for="domainSelect">도메인별 점수</label>
          <select id="domainSelect">
            <option value="">-- 도메인 선택 --</option>
            <option value="환경압력">환경압력 (0~5점)</option>
            <option value="환경수준">환경수준 (0~10점)</option>
            <option value="환경보건수준">환경보건수준 (0~5점)</option>
            <option value="민감인구">민감인구 (0~3점)</option>
            <option value="사회경제적수준">사회경제적 수준 (0~3점)</option>
          </select>

          <div class="hint" style="margin-top: 12px;">
            <div>※ 각 도메인별 변수들의 평균 점수</div>
            <div style="margin-top:6px;">※ 소수점 한자리로 표시(반올림)</div>
          </div>
        </div>

        <!-- 환경보건 취약지수 카드 -->
        <div class="panel-card">
          <div class="row" style="margin-bottom: 6px;">
            <span class="pill">종합</span>
          </div>

          <button class="btn" id="vulnerabilityBtn" type="button">
            환경보건 취약지수 보기
          </button>

          <div class="hint" style="margin-top: 12px;">
            <div>※ 환경압력 × (환경수준+환경보건수준) × (민감인구+사회경제수준)</div>
            <div style="margin-top:6px;">※ 녹색(낮음) → 황색(중간) → 적색(높음)</div>
          </div>
        </div>

        <!-- 기타 기능 카드 -->
        <div class="panel-card">
          <div style="margin-top: 0px;">
            <button class="btn" id="exportBtn" type="button">이미지로 저장</button>
          </div>

          <div class="hint" style="margin-top: 12px;">
            <div>※ 흰 배경 + 행정동 폴리곤 + 범례 포함</div>
            <div style="margin-top:6px;">※ 타일맵 제외, 깔끔한 PNG 이미지로 저장</div>
            <div style="margin-top:6px;">데이터: <code>ulsan_dong_indicators.geojson</code></div>
          </div>
        </div>
      </aside>

      <main class="map-wrap">
        <div id="map"></div>
      </main>
    </div>

    <div class="footer">
      지역별 환경보건 취약지수 시각화 맵 · 정적 웹(HTML/JS) · Leaflet 기반
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
  <script src="https://unpkg.com/leaflet-easyprint@2.1.9/dist/bundle.js"></script>

  <script>
    // ====== 도메인별 변수 매핑 (필요시 수정) ======
    const DOMAIN_MAPPING = {
      "환경압력": [
        "인구밀도(명/k㎡)",
        "유동인구(명)",
        "행정구역 내 산단 면적",
        "환경오염물질배출 사업장 수(개)",
        "제조업 종사자 수(명)",
        "추정교통량(대/일)",
        "차량주행거리(km)",
        "도로길이(km)",
        "유해물질 배출(CAPSS)"
      ],
      "환경수준": [
        "PM 2.5 농도",
        "NO2 농도",
        "O3 농도",
        "환경 소음"
      ],
      "환경보건수준": [
        "천식 유병률",
        "비염 유병률",
        "COPD 유병률",
        "아토피피부염유병률",
        "결막염 유병률"
      ],
      "민감인구": [
        "65세 이상 노령인구 비율",
        "5세 미만 어린이 비율"
      ],
      "사회경제적수준": [
        "노후건축물 현황",
        "공원접근성",
        "병원수",
        "기초생활수급자 비율",
        "초중고 학교 수",
        "학원, 교습소 수",
        "소득정도"
      ]
    };

    // 도메인별 점수 범위
    const DOMAIN_SCORES = {
      "환경압력": { min: 0, max: 5 },
      "환경수준": { min: 0, max: 10 },
      "환경보건수준": { min: 0, max: 5 },
      "민감인구": { min: 0, max: 3 },
      "사회경제적수준": { min: 0, max: 3 }
    };

    // ====== 설정 ======
    const GEOJSON_URL = "./ulsan_dong_indicators.geojson";
    const NAME_FIELD = "ADM_NM";
    const K_VALUE = 10; // 고정값

    let map = L.map("map").setView([35.55, 129.30], 11);
    const base = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(map);

    let geoLayer = null;
    let legendControl = null;
    let geoData = null;
    let isNormalized = false; // 정규화 상태
    let currentMode = 'variable'; // 'variable', 'domain', 'vulnerability'

    function getColor(idx, k) {
      const ramps = {
        5:  ["#ffffcc","#fed976","#feb24c","#fd8d3c","#e31a1c"],
        7:  ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#f03b20","#bd0026"],
        10: ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#bd0026","#800026","#4d0018"]
      };
      const pal = ramps[k] || ramps[10];
      return pal[Math.min(idx, pal.length - 1)];
    }

    // 도메인용 색상 팔레트 (연한 황색 -> 청색)
    function getDomainColor(idx, k) {
      const ramps = {
        5:  ["#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494"],
        7:  ["#ffffcc","#c7e9b4","#7fcdbb","#41b6c4","#2c7fb8","#225ea8","#253494"],
        10: ["#ffffcc","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58","#081d58"]
      };
      const pal = ramps[k] || ramps[10];
      return pal[Math.min(idx, pal.length - 1)];
    }

    // 취약지수용 색상 팔레트 (녹색 -> 황색 -> 적색)
    function getVulnerabilityColor(idx, k) {
      const ramps = {
        5:  ["#22c55e","#84cc16","#eab308","#f97316","#ef4444"],
        7:  ["#22c55e","#65a30d","#84cc16","#eab308","#f97316","#f87171","#ef4444"],
        10: ["#22c55e","#4ade80","#84cc16","#a3e635","#eab308","#fbbf24","#f97316","#fb923c","#ef4444","#dc2626"]
      };
      const pal = ramps[k] || ramps[10];
      return pal[Math.min(idx, pal.length - 1)];
    }

    function fmt(v, isDomain = false) {
      if (v === null || v === undefined || Number.isNaN(v)) return "NA";
      const n = parseFloat(v);
      
      if (isDomain) {
        return n.toFixed(1); // 도메인 점수는 소수점 1자리
      }
      
      if (isNormalized) {
        return Math.round(n).toString(); // 정규화된 값은 정수로 표시
      }
      return Math.round(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function computeNaturalBreaks(values, k) {
      return ss.jenks(values, k); // 길이 k+1 경계
    }

    // Min-Max 정규화 함수 (0~10 범위)
    function normalizeToRange(values, minRange = 0, maxRange = 10) {
      const validVals = values.filter(v => v !== null && v !== undefined && !Number.isNaN(v));
      if (validVals.length === 0) return values;
      
      const minVal = Math.min(...validVals);
      const maxVal = Math.max(...validVals);
      
      if (minVal === maxVal) {
        // 모든 값이 같으면 중간값 반환
        const midVal = (minRange + maxRange) / 2;
        return values.map(v => (v !== null && v !== undefined && !Number.isNaN(v)) ? midVal : v);
      }
      
      return values.map(v => {
        if (v === null || v === undefined || Number.isNaN(v)) return v;
        return minRange + ((v - minVal) / (maxVal - minVal)) * (maxRange - minRange);
      });
    }

    // 도메인 점수 계산
    function calculateDomainScores() {
      if (!geoData) return;

      geoData.features.forEach(feature => {
        // 각 변수를 0~10으로 정규화
        Object.keys(DOMAIN_MAPPING).forEach(domain => {
          const vars = DOMAIN_MAPPING[domain];
          const values = [];
          
          vars.forEach(varName => {
            if (feature.properties[varName + '_normalized_0_10'] !== undefined) {
              const val = feature.properties[varName + '_normalized_0_10'];
              if (val !== null && val !== undefined && !Number.isNaN(val)) {
                values.push(val);
              }
            }
          });
          
          if (values.length > 0) {
            // 평균 계산
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            
            // 도메인별 점수 범위로 재정규화
            const scoreRange = DOMAIN_SCORES[domain];
            const domainScore = (avg / 10) * (scoreRange.max - scoreRange.min) + scoreRange.min;
            
            feature.properties['domain_' + domain] = domainScore;
          } else {
            feature.properties['domain_' + domain] = null;
          }
        });

        // 환경보건 취약지수 계산
        const envPressure = feature.properties['domain_환경압력'] || 0;
        const envQuality = feature.properties['domain_환경수준'] || 0;
        const envHealth = feature.properties['domain_환경보건수준'] || 0;
        const sensitive = feature.properties['domain_민감인구'] || 0;
        const socioEcon = feature.properties['domain_사회경제적수준'] || 0;
        
        const vulnerability = envPressure * (envQuality + envHealth) * (sensitive + socioEcon);
        feature.properties['vulnerability_index'] = vulnerability;
      });
    }

    // 모든 변수를 0~10으로 정규화
    function normalizeAllVariables() {
      if (!geoData) return;

      const allVars = populateVarsFromGeoJSON(geoData);
      
      allVars.forEach(varName => {
        const allVals = geoData.features.map(f => f.properties[varName]);
        const normalized = normalizeToRange(allVals, 0, 10);
        
        geoData.features.forEach((f, idx) => {
          f.properties[varName + '_normalized_0_10'] = normalized[idx];
        });
      });
    }

    function buildLegend(breaks, k, displayName, mode = 'variable') {
      if (legendControl) legendControl.remove();

      legendControl = L.control({ position: "bottomright" });
      legendControl.onAdd = function () {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `<div class="title">${displayName}</div>`;
        
        if (mode === 'variable' && isNormalized) {
          // 변수의 정규화된 경우 숫자만 표기 (level 제거)
          for (let i = 0; i < k; i++) {
            const color = getColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${i + 1}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">1 (낮음) ~ ${k} (높음)</div>`;
        } else if (mode === 'vulnerability') {
          // 취약지수는 중앙값만 표기
          for (let i = 0; i < k; i++) {
            const from = breaks[i];
            const to = breaks[i + 1];
            const midValue = (from + to) / 2;
            const color = getVulnerabilityColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${fmt(midValue, true)}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">녹색(안전) → 황색(보통) → 적색(취약)</div>`;
        } else if (mode === 'domain') {
          // 도메인 점수는 숫자만 표기 (level 제거)
          for (let i = 0; i < k; i++) {
            const color = getDomainColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${i + 1}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">1 (낮음) ~ ${k} (높음)</div>`;
        } else {
          // 원본 값은 중앙값만 표기
          for (let i = 0; i < k; i++) {
            const from = breaks[i];
            const to = breaks[i + 1];
            const midValue = (from + to) / 2;
            const color = getColor(i, k);
            div.innerHTML += `
              <div class="item">
                <span class="swatch" style="background:${color}"></span>
                <span>${fmt(midValue)}</span>
              </div>`;
          }
          div.innerHTML += `<div class="meta">Natural Breaks, k=${k}</div>`;
        }
        return div;
      };
      legendControl.addTo(map);
    }

    function styleFeature(feature, dataKey, breaks, k, mode = 'variable') {
      let v = feature.properties[dataKey];
      
      if (v === null || v === undefined || Number.isNaN(v)) {
        return { color: "#9ca3af", weight: 1, fillOpacity: 0.25, fillColor: "#e5e7eb" };
      }
      
      let idx = k - 1;
      for (let i = 0; i < k; i++) {
        if (v <= breaks[i + 1]) { idx = i; break; }
      }
      
      let colorFunc = getColor; // 기본: 변수용 색상
      if (mode === 'vulnerability') {
        colorFunc = getVulnerabilityColor;
      } else if (mode === 'domain') {
        colorFunc = getDomainColor;
      }
      
      return { color: "#6b7280", weight: 1, fillOpacity: 0.78, fillColor: colorFunc(idx, k) };
    }

    function renderVariable(varName) {
      if (!geoData) return;
      currentMode = 'variable';

      const rawVals = geoData.features
        .map(f => f.properties[varName])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (rawVals.length === 0) {
        alert(`'${varName}' 변수에 유효한 숫자값이 없습니다.`);
        return;
      }

      let vals = rawVals;
      let dataKey = varName;
      
      if (isNormalized) {
        // 0~10 정규화된 값 사용
        vals = geoData.features
          .map(f => f.properties[varName + '_normalized_0_10'])
          .filter(v => typeof v === "number" && !Number.isNaN(v));
        dataKey = varName + '_normalized_0_10';
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'variable'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          let displayValue = feature.properties[varName];
          
          if (isNormalized) {
            const normVal = feature.properties[varName + '_normalized_0_10'];
            const level = Math.round(normVal);
            layer.bindTooltip(`<b>${nm}</b><br/>${varName}: ${level}`, { sticky: true });
          } else {
            layer.bindTooltip(`<b>${nm}</b><br/>${varName}: ${fmt(displayValue)}`, { sticky: true });
          }
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      buildLegend(breaks, kEff, varName, 'variable');
    }

    function renderDomain(domainName) {
      if (!geoData) return;
      currentMode = 'domain';

      const dataKey = 'domain_' + domainName;
      const vals = geoData.features
        .map(f => f.properties[dataKey])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (vals.length === 0) {
        alert(`'${domainName}' 도메인 점수를 계산할 수 없습니다.`);
        return;
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'domain'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          const score = feature.properties[dataKey];
          layer.bindTooltip(`<b>${nm}</b><br/>${domainName}: ${fmt(score, true)}점`, { sticky: true });
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      const scoreRange = DOMAIN_SCORES[domainName];
      const displayName = `${domainName} (${scoreRange.min}~${scoreRange.max}점)`;
      buildLegend(breaks, kEff, displayName, 'domain');
    }

    function renderVulnerability() {
      if (!geoData) return;
      currentMode = 'vulnerability';

      const dataKey = 'vulnerability_index';
      const vals = geoData.features
        .map(f => f.properties[dataKey])
        .filter(v => typeof v === "number" && !Number.isNaN(v));

      if (vals.length === 0) {
        alert('환경보건 취약지수를 계산할 수 없습니다.');
        return;
      }

      const uniq = Array.from(new Set(vals)).length;
      const kEff = Math.max(2, Math.min(K_VALUE, uniq));
      const breaks = computeNaturalBreaks(vals, kEff);

      if (geoLayer) geoLayer.remove();

      geoLayer = L.geoJSON(geoData, {
        style: (f) => styleFeature(f, dataKey, breaks, kEff, 'vulnerability'),
        onEachFeature: (feature, layer) => {
          const nm = feature.properties[NAME_FIELD] ?? "";
          const score = feature.properties[dataKey];
          layer.bindTooltip(`<b>${nm}</b><br/>환경보건 취약지수: ${fmt(score, true)}`, { sticky: true });
        }
      }).addTo(map);

      try {
        map.fitBounds(geoLayer.getBounds(), { padding: [14, 14] });
      } catch (e) {}

      buildLegend(breaks, kEff, '환경보건 취약지수', 'vulnerability');
    }

    // ===== Export 모드 관리 =====
    
    /**
     * Export 모드 진입 - basemap 제거 및 흰 배경 적용
     * 3가지 방식 중 가장 안정적인 방식 사용
     */
    function enterExportMode() {
      // 방법 1: removeLayer (추천) - 가장 깔끔하고 완전한 제거
      if (base && map.hasLayer(base)) {
        map.removeLayer(base);
      }
      
      // 흰 배경 적용
      const mapElement = document.getElementById('map');
      mapElement.classList.add('exporting');
      
      // 지도 강제 리렌더링
      map.invalidateSize();
      
      console.log('Export mode: ON (basemap removed, white background applied)');
    }
    
    /**
     * Export 모드 종료 - basemap 복원 및 원래 스타일 복구
     */
    function leaveExportMode() {
      // basemap 복원
      if (base && !map.hasLayer(base)) {
        map.addLayer(base);
      }
      
      // 흰 배경 제거
      const mapElement = document.getElementById('map');
      mapElement.classList.remove('exporting');
      
      // 지도 강제 리렌더링
      map.invalidateSize();
      
      console.log('Export mode: OFF (basemap restored)');
    }
    
    // ===== EasyPrint 컨트롤 초기화 =====
    let printControl = null;
    
    function initPrintControl() {
      if (printControl) return;
      
      printControl = L.easyPrint({
        title: '지도 이미지로 저장',
        position: 'topleft',
        exportOnly: true,
        hideControlContainer: true,
        sizeModes: ['Current'],
        filename: 'ulsan_map',
        // 범례가 숨겨지지 않도록 hideClasses에서 제외
        hideClasses: ['leaflet-control-zoom', 'leaflet-control-attribution'],
        // 타일 로딩 완료 대기
        tileWait: 500,
        customWindowTitle: '울산 환경보건 취약지수'
      });
      
      // 컨트롤을 지도에 추가하지만 숨김
      printControl.addTo(map);
    }
    
    // ===== 이미지 내보내기 메인 함수 =====
    async function exportMapAsImage() {
      if (!printControl) initPrintControl();
      
      // 파일명 생성
      let fileName = '울산_환경보건취약지수';
      
      if (currentMode === 'variable') {
        const varSelect = document.getElementById('varSelect');
        const varName = varSelect.value;
        const normalizeText = isNormalized ? '_정규화' : '';
        fileName += `_${varName}${normalizeText}`;
      } else if (currentMode === 'domain') {
        const domainSelect = document.getElementById('domainSelect');
        const domainName = domainSelect.value;
        fileName += `_${domainName}`;
      } else if (currentMode === 'vulnerability') {
        fileName += '_종합취약지수';
      }
      
      const timestamp = new Date().toISOString().slice(0, 10);
      printControl.options.filename = `${fileName}_${timestamp}`;
      
      try {
        console.log('=== Image Export Started ===');
        console.log('Filename:', `${fileName}_${timestamp}.png`);
        
        // 1. Export 모드 진입
        enterExportMode();
        
        // 2. 폰트 및 DOM 렌더링 완료 대기
        if (document.fonts && document.fonts.ready) {
          await document.fonts.ready;
        }
        
        // 3. 프레임 렌더링 대기 (2 frames)
        await new Promise(resolve => {
          requestAnimationFrame(() => {
            requestAnimationFrame(resolve);
          });
        });
        
        // 4. 추가 안정화 대기 (100ms)
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // 5. 이미지 캡처 실행
        console.log('Capturing map image...');
        printControl.printMap('CurrentSize', fileName);
        
        // 6. 캡처 완료 대기 (easyPrint 내부 처리 시간)
        await new Promise(resolve => setTimeout(resolve, 500));
        
        console.log('=== Image Export Completed ===');
        
      } catch (error) {
        console.error('Image export failed:', error);
        alert('이미지 생성에 실패했습니다. 다시 시도해주세요.');
      } finally {
        // 7. 반드시 Export 모드 종료 (에러 발생 시에도)
        leaveExportMode();
      }
    }
    
    /*
    ===== Basemap 제거 방식 비교 =====
    
    방법 1: removeLayer / addLayer (현재 적용) ✅ 추천
    - 장점: 
      * 가장 깔끔하고 완전한 제거
      * 타일 요청 중단, 메모리 해제
      * 캡처 결과가 가장 안정적
    - 단점:
      * 복원 시 타일 재로딩 (약간의 지연)
    - 사용: map.removeLayer(base) / map.addLayer(base)
    
    방법 2: setOpacity
    - 장점:
      * 레이어 유지로 복원 빠름
      * 타일 캐시 유지
    - 단점:
      * opacity=0이어도 타일이 캡처에 희미하게 포함될 수 있음
      * 완전한 제거가 아님
    - 사용: base.setOpacity(0) / base.setOpacity(1)
    
    방법 3: container display
    - 장점:
      * CSS 레벨 제어
      * 레이어 객체 유지
    - 단점:
      * Leaflet 내부 상태와 불일치 가능
      * display:none이 캡처 프로세스를 방해할 수 있음
      * 크로스 브라우저 호환성 이슈
    - 사용: base.getContainer().style.display='none' / 'block'
    
    결론: 방법 1 (removeLayer) 사용 권장
    - 깔끔한 흰 배경 보장
    - 타일 잔상 없음
    - 복원 시 약간의 지연은 사용자 경험에 큰 영향 없음
    */
    
    /*
    ===== 범례 누락 방지 체크리스트 =====
    
    1. hideClasses 확인 ✅
       - 'legend' 클래스가 hideClasses에 포함되지 않았는지 확인
       - 현재: ['leaflet-control-zoom', 'leaflet-control-attribution']
       - legend 관련 클래스 제외됨
    
    2. z-index 확인 ✅
       - legend의 z-index가 충분히 높은지 확인
       - 현재: CSS에서 별도 설정 없으나 Leaflet control 기본값 사용
       - 필요시 .legend { z-index: 1000; } 추가 가능
    
    3. position 확인 ✅
       - legendControl.options.position = 'bottomright'
       - Leaflet이 자동으로 올바른 위치에 배치
    
    4. backdrop-filter 제거 ✅
       - export 모드에서 .exporting .legend { backdrop-filter: none; }
       - 캡처 아티팩트 방지
    
    5. 캡처 범위 확인 ✅
       - easyPrint는 .leaflet-container 전체를 캡처
       - legend가 .leaflet-control-container 내부에 있어 자동 포함
    
    6. 렌더링 타이밍 ✅
       - document.fonts.ready 대기
       - requestAnimationFrame 2회 대기
       - 100ms 추가 대기
       - 충분한 렌더링 시간 보장
    */

    function populateVarsFromGeoJSON(geojson) {
      const props = geojson.features?.[0]?.properties || {};
      const candidates = Object.keys(props).filter(k => 
        k !== NAME_FIELD && 
        k !== "join_key" && 
        !k.endsWith("_normalized_0_10") &&
        !k.startsWith("domain_") &&
        k !== "vulnerability_index"
      );
      const vars = candidates.filter(vn =>
        geojson.features.some(f => typeof f.properties[vn] === "number" && !Number.isNaN(f.properties[vn]))
      );
      return vars;
    }

    async function init() {
      const res = await fetch(GEOJSON_URL);
      geoData = await res.json();

      // 모든 변수를 0~10으로 정규화
      normalizeAllVariables();
      
      // 도메인 점수 계산
      calculateDomainScores();
      
      // EasyPrint 컨트롤 초기화
      initPrintControl();

      const varSelect = document.getElementById("varSelect");
      const domainSelect = document.getElementById("domainSelect");
      const exportBtn = document.getElementById("exportBtn");
      const vulnerabilityBtn = document.getElementById("vulnerabilityBtn");
      const normalizeToggle = document.getElementById("normalizeToggle");
      const normalizeStatus = document.getElementById("normalizeStatus");

      const vars = populateVarsFromGeoJSON(geoData);
      if (vars.length === 0) {
        varSelect.innerHTML = `<option value="">(표시할 변수가 없습니다)</option>`;
        return;
      }

      varSelect.innerHTML = vars.map(v => `<option value="${v}">${v}</option>`).join("");

      const defaultVar = vars.includes("인구밀도(명/k㎡)") ? "인구밀도(명/k㎡)" : vars[0];
      varSelect.value = defaultVar;

      renderVariable(defaultVar);

      // 변수 선택 변경 시
      varSelect.addEventListener("change", () => {
        domainSelect.value = "";
        renderVariable(varSelect.value);
      });

      // 도메인 선택 변경 시
      domainSelect.addEventListener("change", () => {
        if (domainSelect.value) {
          renderDomain(domainSelect.value);
        }
      });

      // 환경보건 취약지수 버튼
      vulnerabilityBtn.addEventListener("click", () => {
        domainSelect.value = "";
        renderVulnerability();
      });

      // 이미지 내보내기 버튼
      exportBtn.addEventListener("click", () => {
        exportMapAsImage();
      });

      // 정규화 토글
      normalizeToggle.addEventListener("click", () => {
        if (currentMode === 'variable') {
          isNormalized = !isNormalized;
          normalizeToggle.classList.toggle("active");
          normalizeStatus.textContent = isNormalized ? "ON" : "OFF";
          renderVariable(varSelect.value);
        }
      });
    }

    init();
  </script>
</body>
</html>
